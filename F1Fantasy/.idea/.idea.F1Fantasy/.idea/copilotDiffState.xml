<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/F1Fantasy/Core/ErrorHandlingMiddleware.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/F1Fantasy/Core/ErrorHandlingMiddleware.cs" />
              <option name="originalContent" value="namespace F1Fantasy.Core;&#10;&#10;public class ErrorHandlingMiddleware&#10;{&#10;    private readonly RequestDelegate _next;&#10;    private readonly ILogger&lt;ErrorHandlingMiddleware&gt; _logger;&#10;&#10;    public ErrorHandlingMiddleware(RequestDelegate next, ILogger&lt;ErrorHandlingMiddleware&gt; logger)&#10;    {&#10;        _next = next;&#10;        _logger = logger;&#10;    }&#10;&#10;    public async Task Invoke(HttpContext context)&#10;    {&#10;        try&#10;        {&#10;            await _next(context);&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            _logger.LogError(ex.Message, &quot;Unhandled exception&quot;);&#10;            context.Response.StatusCode = 500;&#10;            context.Response.ContentType = &quot;application/json&quot;;&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="namespace F1Fantasy.Core;&#10;&#10;public class ErrorHandlingMiddleware&#10;{&#10;    private readonly RequestDelegate _next;&#10;    private readonly ILogger&lt;ErrorHandlingMiddleware&gt; _logger;&#10;&#10;    public ErrorHandlingMiddleware(RequestDelegate next, ILogger&lt;ErrorHandlingMiddleware&gt; logger)&#10;    {&#10;        _next = next;&#10;        _logger = logger;&#10;    }&#10;&#10;    public async Task Invoke(HttpContext context)&#10;    {&#10;        try&#10;        {&#10;            await _next(context);&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            _logger.LogError(ex, &quot;Unhandled exception&quot;);&#10;            context.Response.StatusCode = 500;&#10;            context.Response.ContentType = &quot;application/json&quot;;&#10;            var errorResponse = new { error = &quot;An unexpected error occurred.&quot; };&#10;            await context.Response.WriteAsJsonAsync(errorResponse);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/F1Fantasy/Core/Policies/Policies.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/F1Fantasy/Core/Policies/Policies.cs" />
              <option name="originalContent" value="namespace F1Fantasy.Core.Policies;&#10;&#10;public class Policies&#10;{&#10;    &#10;}" />
              <option name="updatedContent" value="namespace F1Fantasy.Core.Policies;&#10;&#10;public static class Policies&#10;{&#10;    public const string CanEditOwnProfile = &quot;CanEditOwnProfile&quot;;&#10;&#10;    public static void AddCustomPolicies(AuthorizationOptions options)&#10;    {&#10;        options.AddPolicy(CanEditOwnProfile, policy =&gt;&#10;            policy.RequireAssertion(context =&gt;&#10;            {&#10;                if (context.Resource is string userId)&#10;                {&#10;                    var claim = context.User.FindFirst(System.Security.Claims.ClaimTypes.NameIdentifier);&#10;                    return claim != null &amp;&amp; claim.Value == userId;&#10;                }&#10;                return false;&#10;            })&#10;        );&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/F1Fantasy/Modules/AdminModule/Repositories/Implementations/AdminRepository.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/F1Fantasy/Modules/AdminModule/Repositories/Implementations/AdminRepository.cs" />
              <option name="originalContent" value="using F1Fantasy.Core.Auth;&#10;using F1Fantasy.Core.Common;&#10;using F1Fantasy.Infrastructure.Contexts;&#10;using F1Fantasy.Modules.AdminModule.Repositories.Interfaces;&#10;using Microsoft.EntityFrameworkCore;&#10;&#10;namespace F1Fantasy.Modules.AdminModule.Repositories.Implementations;&#10;&#10;public class AdminRepository : IAdminRepository&#10;{&#10;    private readonly WooF1Context _context;&#10;&#10;    public AdminRepository(WooF1Context context)&#10;    {&#10;        _context = context;&#10;    }&#10;    &#10;    public async void UpdateSeasonStatus(int year, bool isActive)&#10;    {&#10;        // Implementation to update the season status in the database&#10;        // This method should interact with the database to set the active status of the season&#10;        // For example, using Entity Framework or Dapper to execute an update query&#10;    }&#10;&#10;    public async Task&lt;Season&gt; GetActiveSeasonAsync()&#10;    {&#10;        return await _context.Seasons.AsNoTracking().FirstOrDefaultAsync(s =&gt; s.IsActive);&#10;    }&#10;&#10;    public async Task&lt;ApplicationUser&gt; UpdateUserRoleAsync(int userId, List&lt;string&gt; roleNames)&#10;    {&#10;        ApplicationUser user = await _context.Users.AsTracking().FirstOrDefaultAsync(u =&gt; u.Id == userId);&#10;        if (user == null)&#10;        {&#10;            return null; // User not found&#10;        }&#10;&#10;        List&lt;ApplicationRole&gt; availableRoles = await _context.Roles.ToListAsync();        &#10;&#10;        // Remove all existing roles for the user&#10;        List&lt;ApplicationUserRole&gt; userRoles = await _context.UserRoles.Include(ur =&gt; ur.Role).Where(ur =&gt; ur.UserId == userId).ToListAsync();&#10;        _context.UserRoles.RemoveRange(userRoles);&#10;        // Add the new role&#10;        var newUserRole = new ApplicationUserRole { UserId = userId, RoleId = role.Id };&#10;        _context.UserRoles.Add(newUserRole);&#10;        await _context.SaveChangesAsync();&#10;        return user;&#10;    }&#10;}" />
              <option name="updatedContent" value="using F1Fantasy.Core.Auth;&#10;using F1Fantasy.Core.Common;&#10;using F1Fantasy.Infrastructure.Contexts;&#10;using F1Fantasy.Modules.AdminModule.Repositories.Interfaces;&#10;using Microsoft.EntityFrameworkCore;&#10;&#10;namespace F1Fantasy.Modules.AdminModule.Repositories.Implementations;&#10;&#10;public class AdminRepository : IAdminRepository&#10;{&#10;    private readonly WooF1Context _context;&#10;&#10;    public AdminRepository(WooF1Context context)&#10;    {&#10;        _context = context;&#10;    }&#10;    &#10;    public async void UpdateSeasonStatus(int year, bool isActive)&#10;    {&#10;        // Implementation to update the season status in the database&#10;        // This method should interact with the database to set the active status of the season&#10;        // For example, using Entity Framework or Dapper to execute an update query&#10;    }&#10;&#10;    public async Task&lt;Season&gt; GetActiveSeasonAsync()&#10;    {&#10;        return await _context.Seasons.AsNoTracking().FirstOrDefaultAsync(s =&gt; s.IsActive);&#10;    }&#10;&#10;    public async Task&lt;ApplicationUser&gt; UpdateUserRoleAsync(int userId, List&lt;string&gt; roleNames)&#10;    {&#10;        ApplicationUser user = await _context.Users.AsTracking().FirstOrDefaultAsync(u =&gt; u.Id == userId);&#10;        if (user == null)&#10;        {&#10;            return null; // User not found&#10;        }&#10;&#10;        // Always ensure Player role is present&#10;        if (!roleNames.Contains(&quot;Player&quot;))&#10;            roleNames.Add(&quot;Player&quot;);&#10;&#10;        // Get all roles from DB&#10;        List&lt;ApplicationRole&gt; availableRoles = await _context.Roles.ToListAsync();&#10;        var selectedRoles = availableRoles.Where(r =&gt; roleNames.Contains(r.Name)).ToList();&#10;&#10;        // Remove all existing roles except Player&#10;        var userRoles = await _context.UserRoles.Where(ur =&gt; ur.UserId == userId).ToListAsync();&#10;        var playerRole = availableRoles.FirstOrDefault(r =&gt; r.Name == &quot;Player&quot;);&#10;        var playerUserRole = userRoles.FirstOrDefault(ur =&gt; ur.RoleId == playerRole.Id);&#10;        _context.UserRoles.RemoveRange(userRoles.Where(ur =&gt; playerRole == null || ur.RoleId != playerRole.Id));&#10;&#10;        // Add missing roles (except Player, which is already present if exists)&#10;        foreach (var role in selectedRoles)&#10;        {&#10;            if (!userRoles.Any(ur =&gt; ur.RoleId == role.Id))&#10;            {&#10;                _context.UserRoles.Add(new ApplicationUserRole { UserId = userId, RoleId = role.Id });&#10;            }&#10;        }&#10;&#10;        await _context.SaveChangesAsync();&#10;        return user;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/F1Fantasy/Modules/UserModule/Repositories/Implementations/UserRepository.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/F1Fantasy/Modules/UserModule/Repositories/Implementations/UserRepository.cs" />
              <option name="originalContent" value="using F1Fantasy.Core.Common;&#10;using F1Fantasy.Infrastructure.Contexts;&#10;using Microsoft.EntityFrameworkCore;&#10;&#10;namespace F1Fantasy.Modules.UserModule.Repositories.Implementations;&#10;&#10;public class UserRepository&#10;{&#10;    private readonly WooF1Context _context;&#10;&#10;    public UserRepository(WooF1Context context)&#10;    {&#10;        _context = context;&#10;    }&#10;&#10;    public async Task&lt;ApplicationUser&gt; UpdateUserAsync(ApplicationUser user)&#10;    {&#10;        var existingUser = await _context.Users.AsNoTracking().FirstOrDefaultAsync(u =&gt; u.Id == user.Id);&#10;        if (existingUser == null)&#10;        {&#10;            throw new Exception($&quot;User with ID {user.Id} not found.&quot;);&#10;        }&#10;        _context.Users.Update(user);&#10;        &#10;        await _context.SaveChangesAsync();&#10;        return user;&#10;    }&#10;&#10;    public async Task&lt;ApplicationUser&gt; GetUserByIdAsync(int id)&#10;    {&#10;        return await _context.Users.AsNoTracking().FirstOrDefaultAsync(d =&gt; d.Id == id);&#10;    }&#10;&#10;    public async Task&lt;List&lt;ApplicationUser&gt;&gt; FindUserByDisplayNameAsync(string name)&#10;    {&#10;        return await _context.Users.AsNoTracking()&#10;            .Where(user =&gt; user.DisplayName != null &amp;&amp; user.DisplayName.ToLower().Contains(name.ToLower()))&#10;            .ToListAsync();&#10;    }&#10;&#10;}" />
              <option name="updatedContent" value="using F1Fantasy.Core.Common;&#10;using F1Fantasy.Infrastructure.Contexts;&#10;using Microsoft.EntityFrameworkCore;&#10;&#10;namespace F1Fantasy.Modules.UserModule.Repositories.Implementations;&#10;&#10;public class UserRepository&#10;{&#10;    private readonly WooF1Context _context;&#10;&#10;    public UserRepository(WooF1Context context)&#10;    {&#10;        _context = context;&#10;    }&#10;&#10;    public async Task&lt;ApplicationUser&gt; UpdateUserAsync(ApplicationUser user)&#10;    {&#10;        var existingUser = await _context.Users.FirstOrDefaultAsync(u =&gt; u.Id == user.Id);&#10;        if (existingUser == null)&#10;        {&#10;            throw new Exception($&quot;User with ID {user.Id} not found.&quot;);&#10;        }&#10;        // Update only the properties you want to allow&#10;        existingUser.DisplayName = user.DisplayName;&#10;        existingUser.Email = user.Email;&#10;        // Add other properties as needed&#10;&#10;        await _context.SaveChangesAsync();&#10;        return existingUser;&#10;    }&#10;&#10;    public async Task&lt;ApplicationUser&gt; GetUserByIdAsync(int id)&#10;    {&#10;        return await _context.Users.AsNoTracking().FirstOrDefaultAsync(d =&gt; d.Id == id);&#10;    }&#10;&#10;    public async Task&lt;List&lt;ApplicationUser&gt;&gt; FindUserByDisplayNameAsync(string name)&#10;    {&#10;        return await _context.Users.AsNoTracking()&#10;            .Where(user =&gt; user.DisplayName != null &amp;&amp; user.DisplayName.ToLower().Contains(name.ToLower()))&#10;            .ToListAsync();&#10;    }&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>